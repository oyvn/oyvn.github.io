<!DOCTYPE html>
<html lang="en">

<head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link href="https://fonts.googleapis.com/css?family=Merriweather:300|Raleway:400,700" rel="stylesheet">
<link rel="stylesheet" href="/assets/css/style.css">
<link rel="shortcut icon" type="image/png" href="/favicon.png">
<title>Git guide: Zero to Rebase</title>
<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Git guide: Zero to Rebase | oyvn</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Git guide: Zero to Rebase" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The aim of this guide is to make you more comfortable with git without having to read a whole book. I will do this by giving you more of an “inside tour” of the inner workings of git." />
<meta property="og:description" content="The aim of this guide is to make you more comfortable with git without having to read a whole book. I will do this by giving you more of an “inside tour” of the inner workings of git." />
<link rel="canonical" href="https://oyvn.github.io/git-zero-to-rebase" />
<meta property="og:url" content="https://oyvn.github.io/git-zero-to-rebase" />
<meta property="og:site_name" content="oyvn" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-08-29T19:00:00+02:00" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"https://oyvn.github.io/git-zero-to-rebase"},"@type":"BlogPosting","url":"https://oyvn.github.io/git-zero-to-rebase","dateModified":"2020-08-29T19:00:00+02:00","datePublished":"2020-08-29T19:00:00+02:00","headline":"Git guide: Zero to Rebase","description":"The aim of this guide is to make you more comfortable with git without having to read a whole book. I will do this by giving you more of an “inside tour” of the inner workings of git.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
</head>

<body>
  <main class="container">
    <section class="about">
      <a href="/"><img src="/assets/portfolio.png" alt="Oh yes, very nerd"></a>
      <h2 id="title">
        <a href="/">Oh yes, very nerd</a>
      </h2>
      <p class="tagline"></p>
      <ul class="social"></ul><nav class="navigation">
        <ul>
          
          <li>
            <a href="/index">Home</a>
          </li>
          
          <li>
            <a href="/about">About</a>
          </li>
          
        </ul>
      </nav><p>&copy;
        2020</p></section>
    <section class="content">
      <div class="post-container">
  <a class="post-link" href="/git-zero-to-rebase">
    <h2 class="post-title">Git guide: Zero to Rebase</h2>
  </a>
  <div class="post-meta">
    <div class="post-date"><i class="icon-calendar"></i>Aug 29, 2020</div><ul class="post-categories"><li>git</li><li>rebase</li><li>tutorial</li></ul></div>
  <div class="post">
    <p>The aim of this guide is to make you more comfortable with git without having to read a whole book.
I will do this by giving you more of an “inside tour” of the inner workings of git.</p>

<p>If you are curious and want to become more comfortable with git, this guide aims to satisfy your curiosity more than “traditional” git guides.</p>

<p>I hope you’ll learn enough here to use git with more confidence, and will know better where to look when you are stuck.</p>

<p><strong>Table of Contents</strong>:</p>
<ul id="markdown-toc">
  <li><a href="#act-1-backups" id="markdown-toc-act-1-backups">Act 1: Backups</a>    <ul>
      <li><a href="#first-steps" id="markdown-toc-first-steps">First steps</a></li>
      <li><a href="#the-repository" id="markdown-toc-the-repository">The repository</a></li>
      <li><a href="#the-objects---commit-tree-and-blob" id="markdown-toc-the-objects---commit-tree-and-blob">The objects - commit, tree and blob</a></li>
      <li><a href="#references-the-hash" id="markdown-toc-references-the-hash">References (the “hash”)</a></li>
      <li><a href="#intermission-index" id="markdown-toc-intermission-index">Intermission: Index</a></li>
    </ul>
  </li>
  <li><a href="#act-2-timelines" id="markdown-toc-act-2-timelines">Act 2: Timelines</a>    <ul>
      <li><a href="#branches" id="markdown-toc-branches">Branches</a></li>
      <li><a href="#refs" id="markdown-toc-refs">Refs</a></li>
      <li><a href="#merging" id="markdown-toc-merging">Merging</a></li>
      <li><a href="#cherry-pick" id="markdown-toc-cherry-pick">Cherry-pick</a></li>
      <li><a href="#rebase" id="markdown-toc-rebase">Rebase</a>        <ul>
          <li><a href="#removing-commits" id="markdown-toc-removing-commits">Removing commits</a></li>
          <li><a href="#adding-more-changes-to-an-old-commit" id="markdown-toc-adding-more-changes-to-an-old-commit">Adding more changes to an old commit</a></li>
          <li><a href="#clean-history-when-collaborating" id="markdown-toc-clean-history-when-collaborating">Clean history when collaborating</a></li>
          <li><a href="#making-the-history-linear" id="markdown-toc-making-the-history-linear">Making the history linear</a></li>
          <li><a href="#fully-reconstructing-the-history" id="markdown-toc-fully-reconstructing-the-history">Fully reconstructing the history</a></li>
        </ul>
      </li>
      <li><a href="#afterword" id="markdown-toc-afterword">Afterword</a></li>
    </ul>
  </li>
</ul>

<h1 id="act-1-backups">Act 1: Backups</h1>

<p>Git is a computer program that creates snapshots – essentially backups – of folders on your computer.
In git, these snapshots are called “commits”.
A commit contains everything in that folder:</p>
<ul>
  <li>The folder structure</li>
  <li>names of files</li>
  <li>contents of files</li>
  <li>metadata of files</li>
</ul>

<p>Git’s strengths come from how it organizes the commits and from all the commands it provides for manipulating, labelling, and comparing them.
Handling commits is what makes git a “Version Control System”.</p>

<p>Git tries to make it <em>very</em> easy to take backups so that you can always find a useful place to return to if needed. Also, having a detailed commit history can help answer questions about the state of things at different points in the past, and about why changes were made. Each commit has info about when it was created, and by whom, as well as a “commit message” written by the committer, which ideally contains important information about why it exists.</p>

<p>Git also has commands for collaborating with others (e.g. push/pull/fetch).
The collaboration essentially means exchanging commits and “branches” (which in git are just labels for commits).
Usually collaboration means sending them to a server where others can retrieve them, but it’s also possible to share them directly with other collaborators.<sup id="fnref:distributed"><a href="#fn:distributed" class="footnote">1</a></sup></p>

<h3 id="first-steps">First steps</h3>

<p>Download git: <a href="https://git-scm.com/download/">https://git-scm.com/download/</a></p>

<p>Git is usually used from the command line, but there are also other ways to use it (<code class="language-plaintext highlighter-rouge">git gui</code>, SourceTree, TortoiseGit to name a few.
<a href="https://git-scm.com/downloads/guis/">Here is a big list of graphical user interfaces for git</a>).</p>

<p>To download an existing repository (for example the one for this blog), run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/oyvn/oyvn.github.io.git
</code></pre></div></div>

<p>To create your own repository in an existing folder, run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git init                      # Creates the repository
git add .                     # Prepares a commit of whatever was in
                              # the folder.
git commit -m"Initial commit" # Stores the commit with the message
                              # "Initial commit"
</code></pre></div></div>

<h2 id="the-repository">The repository</h2>

<p>A “repository” (repo) is a collection of commits.
When you use <a href="https://git-scm.com/docs/git-init"><code class="language-plaintext highlighter-rouge">git init</code></a> to create a repo inside a folder, git adds a hidden folder called “.git” inside it. The .git folder is where it puts all the commits.</p>

<p>The rest of your folder is now referred to as the “working directory”.</p>

<p>When you create a commit, git stores all the files and folders as “objects” in the .git folder.
Together, the stored objects contain all the information necessary to recreate the contents of the working directory.</p>

<p>When you retrieve a repo with <a href="https://git-scm.com/docs/git-clone"><code class="language-plaintext highlighter-rouge">git clone</code></a>, git essentially retrieves the .git folder and recreates – “checks out” – the working directory from the objects.</p>

<p>There are a few different types of git objects, let’s take a closer look.</p>

<h2 id="the-objects---commit-tree-and-blob">The objects - commit, tree and blob</h2>

<p>In git, everything is files.
All objects are stored as files in the .git repo.
Objects have different types depending on what data they contain.
An object’s file name is usually a string of gibberish that serves as a unique reference to that object.</p>

<p>When you call <a href="https://git-scm.com/docs/git-commit"><code class="language-plaintext highlighter-rouge">git commit</code></a>, git creates a “commit” object, as well as “tree” objects for each folder, and “blob” objects for each file in the snapshot.
The blob is the simplest, it’s just a copy of the file, except for the name, which is a gibberish reference instead.</p>

<p>If you look in <code class="language-plaintext highlighter-rouge">.git/objects</code> you will find all commit, tree, and blob objects in your repo, all with gibberish names.</p>

<p>By not associating objects with file or folder names, the object can be reused even if the name or location of a file or folder changes, as long as the contents remain unchanged.</p>

<p>A tree object contains:</p>

<ul>
  <li>The name and a reference for every immediate sub-folder. The reference is to a tree object describing the sub-folder’s contents.</li>
  <li>The name and a reference for every file in the folder. The reference is to a blob object with the file contents.</li>
</ul>

<p>A commit object contains:</p>

<ul>
  <li>The committer and author<sup id="fnref:commiter_author"><a href="#fn:commiter_author" class="footnote">2</a></sup> (That’s you, if you made the commit – your name and email address as configured via <a href="https://git-scm.com/docs/git-config"><code class="language-plaintext highlighter-rouge">git config</code></a>).</li>
  <li>The current date and time.</li>
  <li>The commit message that you authored in the process of committing.</li>
  <li>A reference to the tree object for the working directory.</li>
  <li>One or more references to other commit objects (“parent commits”).</li>
</ul>

<p>At this point I want you to notice a few things:</p>

<ul>
  <li>Each commit points to a parent.
This means the commit can be understood as building on something that came before it.</li>
  <li>Even though a commit is thought of as a <em>change</em>, or <em>difference</em> (also called a “delta”), it is stored by git as a standalone snapshot.
Any information about what change it represents is computed when needed, by comparing commits.</li>
  <li>Because objects are referred to by reference, any time an object already exists git just refers to the existing object.
So when your commit only changes one file, only one new blob object (and at least one tree object) needs to be created.</li>
  <li>Retrieving any object by its reference just means finding a file with a certain name.</li>
</ul>

<p>Objects are described in depth in the <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects">Git Internals</a> chapter of the free Pro Git Book.
I recommend it if you are curious, it’s where I learned this.</p>

<p>Now let’s take a closer look at the unique gibberish reference (“hash”).</p>

<h2 id="references-the-hash">References (the “<a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">hash</a>”)</h2>
<p>This section might be heavy, but keep going, it gets to the heart of many of git’s quirks.</p>

<p>In git, there are hashes everywhere, displayed as long strings of numbers and letters.
All objects have hashes, but you mostly see commit hashes, for example when you run <a href="https://git-scm.com/docs/git-log"><code class="language-plaintext highlighter-rouge">git log</code></a>.</p>

<p style="text-align: center;"><img src="assets/git-log.png" alt="git log" title="git log output." /></p>
<p style="text-align: center;">git log output from this blog’s repo.</p>

<p>The hash is calculated from the contents of a given object, and is  completely unique to that object.
It’s often called the “sha” of the commit, because the hash is of the type <a href="https://en.wikipedia.org/wiki/SHA-1">sha1</a>.</p>

<p>A hash (or “digest”) is a big number which always a certain length.
For sha1, the length is 160 bits, or 20 bytes<sup id="fnref:sha1_finite"><a href="#fn:sha1_finite" class="footnote">3</a></sup>.
In git, these bytes are always displayed as a text string of 40 <a href="https://en.wikipedia.org/wiki/Hexadecimal">hexadecimal</a> characters (0-9, a-f)<sup id="fnref:sha_length"><a href="#fn:sha_length" class="footnote">4</a></sup>.</p>

<p>The hash is created by taking the data (the input) and doing some convoluted math on it.
The input can be any data, of any length.
In git, objects serve as inputs.</p>

<p>The convoluted math is such that the hash follows some very strict rules:</p>

<ul>
  <li>The length of the hash is the same regardless of the length of the input.</li>
  <li>The hash is always the same every time if the input is the same.</li>
  <li>The hash is always <em>completely</em> different if the input is even <em>slightly</em> different, even if a single bit is changed, added or removed.</li>
  <li>Finding an input for a given hash (i.e. calculating the hash backwards) is impossible.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sha1("a"):
    86f7e437faa5a7fce15d1ddcb9eaeaea377667b8
sha1("To die, to sleep - to sleep, perchance to dream - ay, there's the rub, for in this sleep of death what dreams may come"):
    0855319deffa58b0458c29edeaa8d6a120d44f35
sha1("to die, to sleep - to sleep, perchance to dream - ay, there's the rub, for in this sleep of death what dreams may come"):
    cab29b74b98c3ad638fe9c1abed72be40d69badc
</code></pre></div></div>

<p style="text-align: center;">Some example SHA1 hashes.</p>

<p>From these rules, we can realize that if <em>any</em> data in an object changes, it is no longer the same object, because the reference will be completely different.
That includes if the time changes by just one second in a commit, or a file changes by just one byte, or if a folder name changes slightly.</p>

<p>It also means that the changes must propagate.
If a file changes, its reference changes, so the tree containing the reference changes, and the commit containing the tree changes.</p>

<p>Any commits descended from the commit must also change.
In fact, looking backwards in time, a commit hash uniquely identifies not just the commit, but also, through its parents and grandparents etc., the entire git history - every tree, blob, and commit - up until that commit. If any detail in any place in the history was different, the current commit would not be the same commit since its hash would be different.</p>

<p>Phew!</p>

<p>Ok. Time for a short story about something slightly different.</p>

<h2 id="intermission-index">Intermission: Index</h2>

<p>When creating a commit, you might want to limit the difference from the previous commit.
You’ll want to group changes in a logical way, to make the commit easier to describe, and to reason about later.</p>

<p>You might have done many changes, though, since the last commit.
Git helps in this situation by allowing you to “stage” changes before commiting them.
<a href="https://git-scm.com/docs/git-add"><code class="language-plaintext highlighter-rouge">git add</code></a> adds files to the “index” i.e. stages them, i.e. marks them as “to be committed”.</p>

<p>When you create the commit, only the staged files and folders receive new objects, the rest are stored as unchanged.</p>

<p>Git creates trees and blobs from the files as you stage them, so that <code class="language-plaintext highlighter-rouge">git commit</code> just needs to create a commit object which references the tree created for the index.</p>

<p>The index often confuses people, but at this point in the guide it might be interesting to realize the similarities between the index and a commit.</p>

<p>Now for the story.</p>

<p>I once mistakenly deleted a new file I had been working on, losing several hours of work since I hadn’t committed it (commit often, people!).
But I remembered that I had staged it at one point, so I knew a blob object was created.
I managed to search the files in my .git folder for a phrase present in the lost file, and I found the file.
The blob had no references pointing to it, so it would have been garbage collected eventually, but since I was quick I managed to recover it, immediately validating having spent hours learning git internals (YAY!).</p>

<p>Now, let’s get back to our “journey”. We have thoroughly explored what a commit is, and how commits relate to each other. Now, lets look at branches, and see why they are both extremely simple and extremely complicated at the same time.</p>

<h1 id="act-2-timelines">Act 2: Timelines</h1>

<h2 id="branches">Branches</h2>

<p>Imagine you have just made a commit. You now want to make some new changes, but you have two different ideas about how to change a file. To fully explore this you need alternate timelines.</p>

<p style="text-align: center;"><img src="assets/branch.svg" alt="branching history" title="non-linear history." /></p>

<p>Recall that each commit has a parent commit.
There is nothing keeping you from creating multiple commits with the same parent.
Conversely, a commit object can actually contain multiple parents.
This means the overall history doesn’t always look like a single line, but can branch out, and come together.</p>

<p style="text-align: center;"><img src="assets/branch_merged.svg" alt="branching history - merged" title="non-linear history - merged." /></p>

<p>If you run <a href="https://git-scm.com/docs/git-branch"><code class="language-plaintext highlighter-rouge">git branch mybranch</code></a> you create a branch called “mybranch” from the current commit.
A branch in git is much like a bookmark, it keeps track of how far you’ve come in a certain timeline.
If you run <a href="https://git-scm.com/docs/git-switch"><code class="language-plaintext highlighter-rouge">git switch mybranch</code></a> you make mybranch your active branch (leaving behind the previously active branch, hopefully with a bookmark attached).</p>

<p>Commits you create will always be added to the currently active branch.
This means the commit you were on when you called <code class="language-plaintext highlighter-rouge">git branch mybranch</code> will eventually have multiple children, one for each branch that was at one point pointing to it.</p>

<p>The concept of branches is widespread in version control, not just in git.
It usually represents a separate stream of development that can live its own life until it’s ready to become part of a larger, shared stream.
Or until it’s discarded in favor of another stream.
In git, the topology created by branching is an inescapable part of the commit history, and there are tools to visualize it (e.g. <code class="language-plaintext highlighter-rouge">gitk</code>).</p>

<p>The names of branches, however, are much more ephemeral than the topology they give rise to, let’s take a look.</p>

<h2 id="refs">Refs</h2>
<p>Git’s branches get their names courtesy of another object type, the “ref” object.
The ref is the simplest object in git, it’s just a reference to a commit.
The file name of the ref is a label given to the commit, for example a branch name (branches are not the only type of ref).</p>

<p>Refs are usually the entry points into the git history: The (human-readable) ref name leads to a commit that leads to its tree and to the history leading up to that commit.</p>

<p>For branches, the reference points to the tip – the most recent commit – on the branch, and this reference is automatically updated as commits are added to the branch.</p>

<p>Tags are another type of ref that are basically branches that never change.</p>

<p>You can find all your branches in <code class="language-plaintext highlighter-rouge">.git/refs/heads</code> and all your tags in <code class="language-plaintext highlighter-rouge">.git/refs/tags</code>.</p>

<p>The “current branch” is a ref called “HEAD” (<code class="language-plaintext highlighter-rouge">.git/HEAD</code>). Switching branches with <code class="language-plaintext highlighter-rouge">git switch</code> or <code class="language-plaintext highlighter-rouge">git checkout</code> changes this ref.</p>

<p>The way the refs work explains a quirk with git’s branches where, if you are looking at a commit, there’s no way to tell for sure what branch you were on when you made the commit, it’s not recorded anywhere. Even if a branch ref is pointing to a commit, the ref might as well have been created after the commit.</p>

<p>Sometimes this information would have been nice to have, but most of the time, the commit speaks for itself. Tags are usually meant to be permanent, so they can also be used to convey context.</p>

<p>Most branches are temporary. There’s usually only one permanent branch into which other branches are eventually incorporated, after which their ref is often deleted.</p>

<p>One of the ways to incorporate a branch is by merging.</p>

<h2 id="merging">Merging</h2>
<p>To <a href="https://git-scm.com/docs/git-merge">merge</a> <code class="language-plaintext highlighter-rouge">mybranch</code> into the <code class="language-plaintext highlighter-rouge">dev</code> branch, run:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git switch dev
git merge mybranch  
</code></pre></div></div>

<p>Now, all commits previously made on <code class="language-plaintext highlighter-rouge">mybranch</code> are part of <code class="language-plaintext highlighter-rouge">dev</code>’s history as well.</p>

<p>Merging is a complex topic, but in the end, a git merge is just a commit with more than one parent, tying two or more timelines together.
The complexity lies in the procedure for determining the tree object for the merge commit.
It must be faithful to the changes that have happened to all the involved timelines since they diverged.
This is hard if multiple timelines have been making different changes to the same lines in the same files.
Git is very good at merging, but sometimes it gives up and you have to manually tell git how certain parts should look (“resolving conflicts”).</p>

<h2 id="cherry-pick">Cherry-pick</h2>
<p>What if you made a commit on a branch and later realize that it should be on another branch, but you don’t want to merge the branches together?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git cherry-pick 1234abcd  # Copies the commit with hash "1234abcd"
                          # onto the current branch.
</code></pre></div></div>

<p>The command <a href="https://git-scm.com/docs/git-cherry-pick"><code class="language-plaintext highlighter-rouge">git cherry-pick</code></a> copies a single commit onto the tip of the current branch.
Remember: Changing anything (including the parent) makes the commit a different commit, so a cherry-picked commit will always be viewed as a different commit to its source commit.
The git log can seem to have multiple copies of a commit if it was cherry-picked between branches which were later merged.</p>

<p>But the <code class="language-plaintext highlighter-rouge">cherry-pick</code> command changes more than the parent of the new commit.
You’ve learned that git stores a standalone snapshot of the folder contents for each commit, but users of git often care most about what changed from one commit to another.
This is what cherry-pick assumes you want.</p>

<p>Instead of giving the new commit the same tree as the source commit, cherry-pick looks at what change the commit represents and tries to apply that change to the new commit’s parent.
This means the new commit usually has a different tree than than its source.</p>

<p>If you think cherry-pick sounds a lot like merging, you are absolutely right.
In fact they share functionality under the hood.</p>

<p>You can also cherry-pick multiple commits.
<code class="language-plaintext highlighter-rouge">git cherry-pick</code> can take a range of commits and will pick them one after the other.
This brings us nicely to rebase.</p>

<h2 id="rebase">Rebase</h2>

<p><a href="https://git-scm.com/docs/git-rebase"><code class="language-plaintext highlighter-rouge">git rebase</code></a> is basically cherry-pick with bells and whistles (lot’s of bells and whistles), Though it’s meant to solve a slightly different problem.</p>

<p>Cherry-pick allows you to solve “I want to move those commits into the current branch”, whereas rebase solves “I want to move the current branch as if its commits were made from a different base commit”.<sup id="fnref:rebase_with_cherry_pick"><a href="#fn:rebase_with_cherry_pick" class="footnote">5</a></sup></p>

<p>Like cherry-pick, rebase makes all the moved commits into different commits: Since the first commit gets a different parent it becomes a different commit, which means the parent of the next commit changes, and so on.</p>

<p>Rebase can be used for many things, in many ways. Finally, here are some examples, demonstrating some of the most significant bells and whistles:</p>

<h3 id="removing-commits">Removing commits</h3>
<p>If you want to remove a commit (and its change) from the history, rebase the commits after it onto the commit before it.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git rebase HEAD~1 --onto HEAD~2  # Removes the 2nd-to-last commit.
</code></pre></div></div>

<h3 id="adding-more-changes-to-an-old-commit">Adding more changes to an old commit</h3>
<p>If you forgot to include something in a commit you made a few commits ago, you can make a new commit, and combine it into the original commit.
For this, you need to use “Interactive Rebase”.
<code class="language-plaintext highlighter-rouge">git rebase --interactive</code> is rebase god-mode, allowing you to freely change the order of commits, and to split the and squash them together during the course of the rebase.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git commit --fixup HEAD~2       # Create a commit to be squashed
                                # into the 3rd-to-last commit.
git rebase --interactive HEAD~4 # Rebase the last 4 commits
                                # interactively.
</code></pre></div></div>
<p>When invoking interactive rebase, git will open a text file listing all the commits, expecting you to edit, save and close it.</p>

<h3 id="clean-history-when-collaborating">Clean history when collaborating</h3>
<p>If you have made commits, but someone else has made commits to the same branch, <code class="language-plaintext highlighter-rouge">git push</code> will fail, telling you to <code class="language-plaintext highlighter-rouge">git pull</code>.
By default, <code class="language-plaintext highlighter-rouge">git pull</code> will merge the other changes into your branch.
These merge commits are particularly confusing, since they are unintended and arbitrary.
<code class="language-plaintext highlighter-rouge">git pull --rebase</code> will instead rebase your changes on top of the new commits as if you made your commits after them.</p>

<h3 id="making-the-history-linear">Making the history linear</h3>
<p>If a branch has merged many other branches into it, the branch’s commit history can look very confusing.
By default, git will drop all merge commits it encounters during a rebase, instead cherry-picking all the regular commits one by one, so the resulting history is linear.</p>

<h3 id="fully-reconstructing-the-history">Fully reconstructing the history</h3>
<p>On the other hand, if you want full control over merge commits as well, <a href="https://git-scm.com/docs/git-rebase#Documentation/git-rebase.txt---rebase-mergesrebase-cousinsno-rebase-cousins"><code class="language-plaintext highlighter-rouge">git rebase --interactive --rebase-merges</code></a> makes you the ultimate ruler of your git history.
You can create or destroy whole branches, merge them at will, and freely move commits wherever they suit your needs, all by rearranging and editing a text file.</p>

<p style="text-align: center;"><img src="assets/galaxy_brain.jpg" alt="git rebase --interactive --rebase-merges" title="Powerful stuff." /></p>
<p style="text-align: center;">Powerful stuff.</p>

<h2 id="afterword">Afterword</h2>
<p>Git is fantastic, even if the commands can be confusing.
Its foundations and core ideas are rock solid and work very well.</p>

<p>I hope you enjoyed this and learned something. I’m new to writing guides like this, and I might well revise it in the future, so feedback is highly appreciated.</p>

<p>Good luck!</p>

<hr />
<p><strong>Footnotes</strong></p>
<div class="footnotes">
  <ol>
    <li id="fn:distributed">

      <p>In git, creating and editing commits is done completely independently from sharing commits with others, which is why git is called a “<em>Distributed</em> Version Control System”.
In contrast, non-distributed version control systems like SVN typically send the commit to the server when it’s created.
This means you won’t feel as free to make commits because you have to deal with any collaboration problems (if someone has made a change to the same file as you) in order to make the commit, and anyone can see the commit you’ve made.
Git allows you to do these activities separately, which makes sense since in principle there is no reason to combine them. <a href="#fnref:distributed" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:commiter_author">
      <p>The commiter and author are the same when the commit is created, but can diverge later e.g. if the commit is “cherry-picked” or “rebased” (cherry-pick and rebased are described later in the guide). <a href="#fnref:commiter_author" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:sha1_finite">
      <p>There are a finite (2¹⁶⁰) number of possible sha1 hashes, so in theory there can be inputs that produce the same hash, but in practice 2¹⁶⁰ is such a ridiculously large number that this never happens (most likely, every unique object in every git repo ever made has a different hash). <a href="#fnref:sha1_finite" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:sha_length">
      <p>For convenience, git allows you to shorten hashes when calling git commands, as long as it can still uniquely identify the commit from the given hex digits. For example,</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git show d69f1
</code></pre></div>      </div>

      <p>is equivalent to</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git show d69f1845b92e7594e54d07af69290b46f07934e4
</code></pre></div>      </div>
      <p><a href="#fnref:sha_length" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:rebase_with_cherry_pick">
      <p>For reference, the following commands accomplish the same as <code class="language-plaintext highlighter-rouge">git rebase &lt;newbase&gt;</code></p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git reset --hard &lt;newbase&gt; # Modify the branch ref so it points to
                           # &lt;newbase&gt;, allowing us to add commits to it
git cherry-pick ..@{1}     # cherry-pick all commits not already present
                           # on the new branch. @{1} refers to where we
                           # were before the git reset (see "reflog").
</code></pre></div>      </div>
      <p><a href="#fnref:rebase_with_cherry_pick" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div></div>

    </section>
  </main>
</body>

</html>
